L2-018 多项式A除以B（25 分）
这仍然是一道关于A/B的题，只不过A和B都换成了多项式。你需要计算两个多项式相除的商Q和余R，其中R的阶数必须小于B的阶数。

输入格式：
输入分两行，每行给出一个非零多项式，先给出A，再给出B。每行的格式如下：

N e[1] c[1] ... e[N] c[N]
其中N是该多项式非零项的个数，e[i]是第i个非零项的指数，c[i]是第i个非零项的系数。各项按照指数递减的顺序给出，保证所有指数是各不相同的非负整数，所有系数是非零整数，所有整数在整型范围内。

输出格式：
分两行先后输出商和余，输出格式与输入格式相同，输出的系数保留小数点后1位。同行数字间以1个空格分隔，行首尾不得有多余空格。注意：零多项式是一个特殊多项式，对应输出为0 0 0.0。但非零多项式不能输出零系数（包括舍入后为0.0）的项。在样例中，余多项式其实有常数项-1/27，但因其舍入后为0.0，故不输出。

输入样例：
4 4 1 2 -3 1 -1 0 -1
3 2 3 1 -2 0 1
输出样例：
3 2 0.3 1 0.2 0 -1.0
1 1 -3.1

分析：对于两个多项式A和B，题目给出的必定不会是连续降幂的，根据多项式的除法原理，我们需要缺幂项补零。例如，题中给出的$x^4-3x^2-x-1$是缺3次幂的，将缺幂项补上之后，就变成了$x^4+0x^3-3x^2-x-1$。由此，我们可以用一个数组来保存一个多项式，即数组的下标对应多项式的指数，下标对应的单元表示多项式的系数，如数组[-1, -1, -3, 0, 1]。
若已知A多项式的最高次幂为t1, B多项式的最高次幂为t2, 则第一次除法商的最高次幂为t1 - t2, 最高次幂的系数为A[t1] / B[t2], 然后用A[i] -= B[i - (t1 - t2)] * A[t1] / B[t2], 其中i从A的最高次幂t1到大于等于t1 - t2, 这样就算完成了一个除法了。例如A = [-1, -1, -3, 0, 1], B = [1, -2, 3], 则t1 = 4, t2= 2, 所以第一次除法商的最高次幂为2, 系数为A[4] / A[2] = 0.3, 循环A[i] -= B[i - (t1 - t2)] * A[t1] / B[t2], i从4到2, 得到新的A=[-1, -1, -10/3, 2/3, 0], 然后重复上面的步骤, 直到A的最高项幂次小于B的最高项幂次, 此时的A就是余项。
[两个可能会让结果出现非零项多项式的测试用例]
    1 2 1
    1 3 1

    1 2 1
    1 2 1

[一个比较好算一点的一般测试用例]
    3 3 1 2 -12 0 -42
    2 1 1 0 -3
    // ouput
    3 2 1.0 1 -9.0 0 -27.0
    1 0 -123.0
具体代码如下：

#include <cstdio>
#include <cmath>
using namespace std;
int nonNegativeNum(double c[], int start) {
    int cnt = 0;
    for (int i = start; i >= 0; i--)
        if (abs(c[i]) + 0.05 >= 0.1) cnt++;
    return cnt;
}
void printPoly(double c[], int start) {
    printf("%d", nonNegativeNum(c, start));
    if (nonNegativeNum(c, start) == 0) printf(" 0 0.0");
    for (int i = start; i >= 0; i--)
        if (abs(c[i]) + 0.05 >= 0.1)
            printf(" %d %.1f", i, c[i]);
}
double c1[3000], c2[3000], c3[3000];
int main() {
    int m = 0, n = 0, t = 0, max1 = -1, max2= -1;
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        scanf("%d", &t);
        max1 = max1 > t ? max1 : t;
        scanf("%lf", &c1[t]);
    }
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &t);
        max2 = max2 > t ? max2 : t;
        scanf("%lf", &c2[t]);
    }
    int t1 = max1, t2 = max2;
    while (t1 >= t2) {
        double c = c1[t1] / c2[t2];
        c3[t1 - t2] = c;
        for (int i = t1, j = t2; j >= 0; j--, i--) c1[i] -= c2[j] * c;
        while (abs(c1[t1]) < 0.000001) t1--;
    }
    printPoly(c3, max1 - max2);
    printf("\n");
    printPoly(c1, t1);
    return 0;
}